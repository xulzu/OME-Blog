<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue使用注意事项及原因 | OME`s Blog</title>
    <meta name="generator" content="VuePress 1.6.0">
    
    <meta name="description" content="">
    <link rel="preload" href="/guizai-blog/assets/css/0.styles.e3eea276.css" as="style"><link rel="preload" href="/guizai-blog/assets/js/app.96325c21.js" as="script"><link rel="preload" href="/guizai-blog/assets/js/7.5d3f53af.js" as="script"><link rel="preload" href="/guizai-blog/assets/js/5.c77aedc3.js" as="script"><link rel="preload" href="/guizai-blog/assets/js/6.b85391b7.js" as="script"><link rel="preload" href="/guizai-blog/assets/js/19.e4d40085.js" as="script"><link rel="preload" href="/guizai-blog/assets/js/4.786ef6ca.js" as="script"><link rel="prefetch" href="/guizai-blog/assets/js/10.d8d2efa4.js"><link rel="prefetch" href="/guizai-blog/assets/js/11.16fb80ef.js"><link rel="prefetch" href="/guizai-blog/assets/js/12.7ce43a03.js"><link rel="prefetch" href="/guizai-blog/assets/js/13.8b79ff86.js"><link rel="prefetch" href="/guizai-blog/assets/js/14.0f241e79.js"><link rel="prefetch" href="/guizai-blog/assets/js/15.859ef99e.js"><link rel="prefetch" href="/guizai-blog/assets/js/16.95661ba2.js"><link rel="prefetch" href="/guizai-blog/assets/js/17.a0cf1209.js"><link rel="prefetch" href="/guizai-blog/assets/js/18.30f26b5c.js"><link rel="prefetch" href="/guizai-blog/assets/js/2.b5167b03.js"><link rel="prefetch" href="/guizai-blog/assets/js/20.d3298f75.js"><link rel="prefetch" href="/guizai-blog/assets/js/21.c5f2dee4.js"><link rel="prefetch" href="/guizai-blog/assets/js/22.dd4732a8.js"><link rel="prefetch" href="/guizai-blog/assets/js/23.8ff61a3f.js"><link rel="prefetch" href="/guizai-blog/assets/js/24.e34c0e96.js"><link rel="prefetch" href="/guizai-blog/assets/js/3.9621ee0c.js"><link rel="prefetch" href="/guizai-blog/assets/js/8.2449d70b.js"><link rel="prefetch" href="/guizai-blog/assets/js/9.8e23ba71.js">
    <link rel="stylesheet" href="/guizai-blog/assets/css/0.styles.e3eea276.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><main class="md-content"><div style="width:100%"><div class="xu-footer" data-v-0cba0054>
	OME`s Blog
</div> <div class="Nav-bar" data-v-7374ad8e><nav data-v-7374ad8e><a href="/guizai-blog/" title="文章" class="nav" data-v-7374ad8e>Article</a><a href="/guizai-blog/category" title="分类" class="nav" data-v-7374ad8e>Category</a><a href="/guizai-blog/about" title="关于" class="nav" data-v-7374ad8e>About</a></nav></div> <!----> <!----> <div class="content__default"><h1 id="vue使用注意事项及原因"><a href="#vue使用注意事项及原因" class="header-anchor">#</a> vue使用注意事项及原因</h1> <h2 id="在此记录一些vue使用注意事项-以及为何如此的原因"><a href="#在此记录一些vue使用注意事项-以及为何如此的原因" class="header-anchor">#</a> 在此记录一些vue使用注意事项，以及为何如此的原因</h2> <h2 id="_1、在v-for中禁止使用random-和作为key绑定元素。尽量不要使用index作为key"><a href="#_1、在v-for中禁止使用random-和作为key绑定元素。尽量不要使用index作为key" class="header-anchor">#</a> 1、在v-for中禁止使用random（）和作为key绑定元素。尽量不要使用index作为key</h2> <p>​    这样的原因是在vue的diff算法中，因为生成新dom节点的开销是比复用旧dom节点的开销大的，所以在vue中为了尽可能的复用旧节点。其中的一个策略是通过新旧元素的key来判断旧元素中是否存在和新元素key一样的节点。在源码中表现如下，elmToMove节点就是通过key在旧元素中获取到的一个节点，因此如果更新前后中存在key相同的节点，那么能够做到复用旧节点。但是如果使用随机数作为key来进行for循环的话，那么key每次更新都不一样，复用也就无从谈起。这是十分没有效率的做法。</p> <p>​    但是为什么也尽量别用index来作为key呢？假设我们数组进行了一个删除操作，那么渲染的数目将会改变，但是对于部分元素的index是不变的，如['a','b','c']对应的索引[0,1,2]。如果我们删除掉'a'.则['b','c']对应的索引为[0,1].从这里我们可以看到。b和c本来可以复用的，但是因为使用索引来作为key，因此会对比旧新 元素 '旧a'-&gt;'新b','旧b'-&gt;'新c'的内容来进行节点更新。这无疑又会增性能开销，复用不完整</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>elmToMove<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">/*如果新VNode与得到的有相同key的节点是同一个VNode则进行patchVnode*/</span>
            <span class="token function">patchVnode</span><span class="token punctuation">(</span>elmToMove<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
            <span class="token comment">/*因为已经patchVnode进去了，所以将这个老节点赋值undefined，之后如果还有新节点与该节点key相同可以检测出来提示已有重复的key*/</span>
            oldCh<span class="token punctuation">[</span>idxInOld<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">undefined</span>
            <span class="token comment">/*当有标识位canMove实可以直接插入oldStartVnode对应的真实Dom节点前面*/</span>
            canMove <span class="token operator">&amp;&amp;</span> nodeOps<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> newStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span>
            newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// same key but different element. treat as new element</span>
            <span class="token comment">/*当新的VNode与找到的同样key的VNode不是sameVNode的时候（比如说tag不一样或者是有不一样type的input标签），创建一个新的节点*/</span>
            <span class="token function">createElm</span><span class="token punctuation">(</span>newStartVnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> parentElm<span class="token punctuation">,</span> oldStartVnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span>
            newStartVnode <span class="token operator">=</span> newCh<span class="token punctuation">[</span><span class="token operator">++</span>newStartIdx<span class="token punctuation">]</span>
          <span class="token punctuation">}</span>
</code></pre></div></div></div> <div class="xu-footer" data-v-287e590a>
	lisence -_- @2020-01-23 OME
</div></main></div><div class="global-ui"></div></div>
    <script src="/guizai-blog/assets/js/app.96325c21.js" defer></script><script src="/guizai-blog/assets/js/7.5d3f53af.js" defer></script><script src="/guizai-blog/assets/js/5.c77aedc3.js" defer></script><script src="/guizai-blog/assets/js/6.b85391b7.js" defer></script><script src="/guizai-blog/assets/js/19.e4d40085.js" defer></script><script src="/guizai-blog/assets/js/4.786ef6ca.js" defer></script>
  </body>
</html>
