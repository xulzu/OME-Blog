---
key: Algorithm
permalink: /pages/algorithm/PriorityQueue
time: '2020-12-04 13:45:45'
---
# 优先队列
## 小根堆
```js

class MinQueue{
	constructor(){
		this.heap=new Array()
	}
	push(item){
		if(!this.heap.length){
			this.heap.push(item)
		}else{
			let insertIndex=this.heap.length
			this.heap.push(item)
			let parentIndex=(insertIndex-1)>>1
			// 插入的节点小于父节点，交换子节点和父节点
			while(this.heap[parentIndex]>item){
				[this.heap[parentIndex],this.heap[insertIndex]]=[this.heap[insertIndex],this.heap[parentIndex]]
				insertIndex=parentIndex
				parentIndex=(insertIndex-1)>>1
			}
		}
	}
	pop(){
		if(!this.heap.length) return 
		let ret=this.heap[0]
		if(this.heap.length===1){
			this.heap.length=0
			return ret
		}
		this.heap[0]=this.heap.pop()
		let downHeap=(downIndex)=>{
			// 没有其他节点了
			if(2*downIndex+1>this.heap.length-1) return;
			let downTo=2*downIndex+1;
			// 找到下一层子节点中较小的一个
			if(downTo+1<this.heap.length&&this.heap[downTo]>this.heap[downTo+1]){
				downTo++
			}
			if(this.heap[downTo]<this.heap[downIndex]){
				[this.heap[downTo],this.heap[downIndex]]=[this.heap[downIndex],this.heap[downTo]]
				downHeap(downTo)
			}
		}
		downHeap(0)
		return ret
	}
}
```
## 大根堆
```js
class MaxQueue {
    constructor() {
        this.heap = []
    }
    push(val) {
        if (!this.heap.length) {
            this.heap.push(val)
        } else {
            let insertIndex = this.heap.length
            this.heap.push(val)
            let parentIndex = (insertIndex - 1) >> 1
            while (this.heap[parentIndex] < this.heap[insertIndex]) {
                [this.heap[parentIndex], this.heap[insertIndex]] = [this.heap[insertIndex], this.heap[parentIndex]]
                insertIndex = parentIndex
                parentIndex = (insertIndex - 1) >> 1
            }
        }
    }
    pop() {
        if (this.heap.length === 0) return
        let ans = this.heap[0]
        if (this.heap.length === 1) {
            this.heap.length = 0
            return ans
        }
        this.heap[0] = this.heap.pop()
        let help = (index) => {
            if (2 * index + 1 >= this.heap.length) return
            let curIndex = 2 * index + 1
            if (curIndex + 1 < this.heap.length && this.heap[curIndex + 1] > this.heap[curIndex]) {
                curIndex++
            }
            if(this.heap[curIndex]>this.heap[index]){
                [this.heap[index],this.heap[curIndex]]=[this.heap[curIndex],this.heap[index]]
                help(curIndex)
            }
        }
        help(0)
        return ans
    }
}
```

